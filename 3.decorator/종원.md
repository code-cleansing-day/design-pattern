# 데코레이터 패턴

> **데코레이터**는 객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결시키는 구조적 디자인 패턴입니다.

## 문제

- 특정 목적을 수행하는 라이브러리
  - 초기 버전: 기본 기능만 제공 -> 다양한 유저들의 다양한 기능 요구
  - 각각의 기능을 제공하는 것은 그리 어렵지 않음 (메서드 추가)
  - 기능들을 조합하기 시작할 때 큰 복잡성 발생 (기능 + 조합을 담당하는 객체가 무분별하게 증가)

## 해결책

- 상속

  - 한계
    - 상속은 정적입니다: 당신은 런타임​(실행시간) 때 기존 객체의 행동을 변경할 수 없습니다. 당신은 전체 객체를 다른 자식 클래스에서 생성된 다른 객체로만 바꿀 수 있습니다.
    - 자식 클래스는 하나의 부모 클래스만 가질 수 있습니다. 대부분 언어에서의 상속은 클래스가 동시에 여러 클래스의 행동을 상속하도록 허용하지 않습니다.

- 구성

  - 래퍼 객체로 결과를 다르게 한다.

## 구조

1. 컴포넌트(interface): 래퍼들과 래핑된 객체들 모두에 대한 공통 인터페이스를 선언
2. 구상 컴포넌트: 래핑되는 객체들의 클래스
3. 기초 데코레이터: 클래스에는 래핑된 객체를 참조하기 위한 필드, 모든 작업들을 래핑된 객체에 위임
4. 구상 데코레이터: 컴포넌트들에 동적으로 추가될 수 있는 추가 행동들을 정의, 기초 데코레이터의 메서드를 오버라이드
5. 클라이언트: 여러 계층의 데코레이터 래핑 가능

---

재귀적 합성

> 데코레이터는 객체의 피부를 변경할 수 있고 전략 패턴은 객체의 내장을 변경할 수 있다고 비유할 수 있습니다...

<!-- 위임, 스택 -->
