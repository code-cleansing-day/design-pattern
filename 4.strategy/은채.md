# 전략패턴 < 행동패턴

> 동일한 문제를 해결하기 위해 다양한 알고리즘을 정의하고, 이들 알고리즘을 캡슐화하여 교환 가능하게 만든다.
>
> ex) 골프에서 다양한 골프채

---

### 사용방법

1. 특정 작업을 다양한 방식으로 수행하는 클래스를 선택한 후 모든 알고리즘을 별도의 클래스들로 추출
2. 콘텍스트(context)​라는 원래 클래스에 전략 중 하나에 대한 참조를 저장하기 위한 필드가 추가.
3. 콘텍스트는 작업을 자체적으로 실행하는 대신 연결된 전략 객체에 위임합니다.( 콘텍스트는 작업에 적합한 알고리즘을 선택할 책임이 없습니다. === 책임분배)

---

- 전략 인터페이스: 모든 구상 전략에 공통이며, 콘텍스트가 전략을 실행하는 데 사용하는 메서드를 선언합니다.
- 구상 전략: 콘텍스트가 사용하는 알고리즘의 다양한 변형들을 구현합니다.
- 콘텍스트: 구상 전략 중 하나에 대한 참조를 유지하고 전략 인터페이스를 통해서만 이 객체와 통신합니다.
- 클라이언트: 특정 전략 객체를 만들어 콘텍스트에 전달합니다.

---

```typescript
interface 계산전략인터페이스 {
  가격: number;
  중가구간: number;
  계산: () => void;
  총액: number;
}

class A타입계산 implements 계산전략인터페이스 {
  private 가격 = 1000;
  private 중가구간 = 30;
  계산() {
    // 계산로직
    return (가격 * 중가구간) / 30;
  }
}
class B타입계산 implements 계산전략인터페이스 {
  private 가격 = 2000;
  private 중가구간 = 50;
  계산() {
    // 계산로직
    return (가격 * 중가구간) / 10;
  }
}

class Context {
  private 전략;
  set전략(_전략: 계산전략인터페이스) {
    this.전략 = _전략;
  }
  실행() {
    this.전략.계산();
  }
}

const context = new Context();

context.set전략(new A타입계산());
const 결과A타입 = context.실행();

// B타입 계산 전략을 설정하고 실행
context.set전략(new B타입계산());
const 결과B타입 = context.실행();
```

_데코레이터와 무엇이 다른가?_

데코레이터는 구조패턴으로 클래스와 객체를 결합하여 기능의 확장 같은 느낌인데, 전략은 확장 보다는 완전 교체의 느낌이 강하다.
